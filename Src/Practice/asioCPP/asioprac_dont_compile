#include <iostream>
#include <asio/ts/buffer.hpp>
#include <asio/ts/internet.hpp>
#include <vector>
#include <thread>


std::vector<char> vBuffer(1*1024);
void GrabSomeData(asio::ip::tcp::socket &socket)
{
    socket.async_read_some(asio::buffer(vBuffer),
            [&](std::error_code ec,std::size_t length){
                if(!ec)
                {
                    std::cout<<"  \n\nRead "<<length<<" bytes\n";
                    for(int i = 0;i<length;i++)
                        std::cout<<vBuffer[i];
                    GrabSomeData(socket);//this is not a recursive nightmare but instead will grab data async
                }
            });
}
int main()
{
    asio::error_code ec;
    asio::io_context context;
    //since we are using async read the context now requires some work to do on current thread as read runs in      bg, thus we provide it with idle work
    asio::io_context::work idleWork(context);
    //create the thread
    std::thread idleContext = std::thread([&](){context.run();});

    asio::ip::tcp::endpoint endpoint(asio::ip::make_address("23.209.46.84",ec),80);
    asio::ip::tcp::socket socket(context);
    socket.connect(endpoint,ec);
    if(ec)
    {
        std::cout<<"Failed to connect to "<<endpoint.address()<<" due to:"<<ec.message()<<std::endl;
    }
    else
    {
        std::cout<<"Connected :"<<endpoint.address()<<std::endl;
    }
    if(socket.is_open())
    {
        GrabSomeData(socket);
        std::string sRequest= 
            "GET /index.html HTTP/1.1\r\n"
            "Host: example.com\r\n"
            "Connection: close\r\n\r\n";
        socket.write_some(asio::buffer(sRequest.data(),sRequest.size()),ec);
        using namespace std::chrono_literals;
        std::this_thread::sleep_for(2000ms);
        context.stop();
        if(idleContext.joinable()) idleContext.join();
        /*
        size_t byte = socket.available();
        std::cout<<byte<<" bytes available to read\n";
        if(byte>0)
        {
            socket.read_some(asio::buffer(vBuffer),ec);
            for(auto c :vBuffer)
                std::cout<<c;
        }
        */
    }
    return 0;
}
